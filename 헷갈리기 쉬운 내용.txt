<문제 풀때!!!>
1. 문제를 어떤 방법으로 풀건지? 
2. 생각한 방법 중 가장 간단하게 구성할 수 있는 방법을 채택
3. 함수는 몇개를 구현하고, 헤더파일은 무엇이 필요할지 결정
4. 비로소 코드 작성 시작!
------------------------------------------------------------------------------
#반드시 0번(째)부터 시작!!

#음수를 표현할 때는 2의 보수를 사용
-2의 보수 : 1의 보수를 취하고 + add 1 to LSB
-음수->양수를 찾을 때 음수와 더했을 때 0을 만드는 양수를 찾고, (-)부호를 붙인다

#signed : 양수, 음수 존재 -> MSB는 부호
#unsigned : 음수x -> MSB도 수치를 나타냄

#double형 변수는 실수를 표현하지만, 아주 큰 숫자를 표현하기 위해 구현된 자료형

#작은따옴표('')에는 문자를 입력하여 아스키코드값으로,
#큰따옴표("")에는 문자열을 입력하여 주소값을 반환.

#문자열의 끝에는 항상 널문자(NULL)가 존재 -> 아스키코드값 0

#False는 0, True는 0이 아닌 수

#overflow : 변수의 크기를 넘어서는 데이터가 들어올 때 발생
- signed 변수의 경우 MSB는 부호를 나타내기 때문에 overflow발생 시 유의
- unsigned 변수의 경우 양의 부호만 존재하므로, LSB부터 크기만큼 자른 데이터가 됨
ex) char x=200; -> x=-56 / unsigned char x=300; -> x= 44

#형변환
-Implicit(자동형변환) : 자료형 중에서 더 큰 범위를 가지는 자료형으로 자동 형변환
-Explicit(명시적 형변환) : 초기화 시 형변환을 명시적으로 표기

#작은 자료형 -> 큰 자료형 으로 데이터가 옮겨갈 때
1. bit extension 
- 양수의 경우 남은 bit가 0으로 채워지고, 음수의 경우 큰 자료형에서 해당 값을 나타내는
bit로 변경
2. signed라면 음수를 그대로 읽지만, unsigned라면 MSB도 수치화하여 읽음

#bit 이동 연산자(<<, >>)
- << : 2배씩 증가. ( x<<2 : x를 왼쪽으로 2bit 이동. 새로 생겨나는 bit는 0으로 채워짐)
- >> : 1/2씩 감소. ( x>>2 : x를 오른쪽으로 2bit 이동. 왼쪽에서 새로 생겨나는 bit는
양수면 0, 음수면 1로 채워짐 -> 실제 나누기 한 값과 다를 수 있음!!

#bit 연산
- x&(1<<3) : 3rd bit가 1이면 참(0이 아닌 값), 0이면 거짓(0)을 반환
- ^ (xor) : 두개의 bit가 서로 다른 경우에 1을 반환

#함수를 구현할 때 -> 공식화해서 만드는 방법이 편할 때도 있다.

#조건 연산자   (조건) ? (true이면) : (false이면)

#2D array -> 1D array로 표현
세로길이가 N, 가로길이가 M인 2차원으로 선언된 배열에서 a[N][M] = a[N*M]이고, 
a[y][x] = a[y*M+x]

#함수에서 프로그램을 종료하고 싶을 때 exit()를 사용

#scanf로 문자를 입력받을 때는 개행을 입력버퍼에 남겨두기 때문에 getchar()로 비워야 한다.
하지만, 숫자를 입력받을 때는 개행을 신경쓰지 않아도 된다. 

#num--; 와 num-1은 다르다.
num-- 는 num에 저장된 값을 1만큼 감소시키는 연산이고, num값이 변한다.
num-1 은 num에 저장된 값을 이용해서 1만큼 감소시키는 연산으로 num값은 변하지 않는다.

# 포인터연산 - 자료형에 따라 한 칸의 크기가 다름
&p[i] = (p+i);
p[i] = *(p+i);

#파일&문자열 관련 함수
- fseek(FILE*stream, 칸 수, origin)
칸수를 결정하는 offset은 1바이트 단위로 움직인다.  origin: SEEK_SET, SEEK_CUR, SEEK_END
성공시 0(false), 실패 시 0이 아닌 값(true) 반환

-feof(FILE*stream)
파일의 끝에 도달한 경우 0이 아닌 값 반환

-fread(저장할 배열, 자료형 크기, n, FILE*stream) 
fp로부터 자료형 크기 데이터 n개를 읽어서 배열에 저장
n개를 모두 읽으면 n, 그렇지 못하거나 파일의 끝 도달시 n보다 작은값 반환

-fwrite(데이터가 있는 배열, 자료형 크기, n, FILE*stream)
자료형 크기의 데이터 n개를 배열로부터 읽어서 fp에 저장
n개를 모두 옮기면 n, 실패시 n보다 작은값 반환

-ftell(FILE*stream)
현재 파일 위치 지시자의 위치를 반환

-fgets, fputs 
텍스트파일의 경우 개행을 기준으로 데이터를 읽거나 출력. 데이터에는 개행이 포함됨

-rewind(FILE*stream)
파일의 맨 앞을 다시 가리켜라

-fprintf(fp, "%s %c %d", name, sex, age)
fp가 가리키는 파일에 텍스트와 바이너리 데이터를 순서대로 출력

-fscanf (fp, "%s %c %d", name, &sex, &age)
fp가 가리키는 파일에 있는 텍스트와 바이너리 데이터를 순서대로 입력받음.

-strlen : 문자열 길이 반환
-strcpy(d, s), strncpy(d,s,n): d를 s에 복사해라
-strcat(d,s), strncat(d,s,n): d에 s를 붙여라
-strchr(str, int ch): str에 'ch'가 있다면 해당 위치를 반환
-strstr(str1, str2): str1에 str2가 포함된다면 해당 위치를 반환 
-strcmp(str1, str2): 두 문자열을 비교해서 문자열이 같다면 0을 반환하고
문자열이 틀리면 -1을 반환한다.

-ctype.h에 있는 함수
toupper: 소문자를 대문자로 변환하여 반환! 
tolower: 대문자를 소문자로 변환하여 반환!
모두 값을 반환하는 함수이므로 다시 초기화하는 과정이 필요

#소수점 이하 출력
서식문자 %.2f를 이용하면 소수 3번째자리에서 자동으로 반올림하여
소수 2번째자리까지 출력




